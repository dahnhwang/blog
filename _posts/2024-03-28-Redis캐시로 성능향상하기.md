---
title: "Redis캐시 @CacheEvict 사용하기"
layout: post
---

AWS 레디스 서버에서 요청들이 줄서서 대기하는 현상이 발생했다. 업무로직에서 특정 캐시네임에 대해 @cacheEvict 시 allEntries=true로 파라미터를 준 때문에 발생한 현상이었다.


{% highlight python %}
KEYS pattern
{% endhighlight %}

<link href="https://redis.io/commands/keys/" rel="stylesheet">

공식문서에 KEYS 기능에 대해 Returns all keys matching pattern. 이라고 명시되어있는데, evict 대상을 찾을때 KEYS 뒤에 * 파라미터(allEntries=true)가 오며 해당 캐시네임과 동일한 모든 키를 탐색하며 부하가 걸린 것.

해결방법으로 @Caching쪽과 @CacheEvict하는 쪽 모두 동일한 구체적인 키값을 주는 것으로 방향을 정했으나, 알고보니 양쪽의 메소드 파라미터의 오브젝트 자체가 서로 달라 수정해야할 범위가 꽤 많았음. 거기다 evict할때 두 개의 캐시키를 동시에 해주는 부분이고, 두 개의 캐시키 모두 서로 다른 파라미터를 물고 있었다. (왜 코드작성자가 냅다 allEntries=true로 evict시켜버렸는지 알 것 같았음)

예를 들어, 룸에 대한 리뷰가 업데이트된다면 해당 룸넘버와 룸 개수에 대한 캐시를 모두 날려줘야하는 상황이다. 

{% highlight java %}
@Cacheable(value = "selectRoomNo", key = "#p0.roomNo")
public String selectRoomNo(Room room) {

}

@Cacheable(value = "selectReviewCount", key = "#p0.roomNo")
public String selectReviewCount(Room room) {

}

@Caching(evict = {
    @CacheEvict(value = "selectRoomNo", key = "#p0.roomNo"),
    @CacheEvict(value = "selectReviewCount", key = "#p0.roomNo")
})
public String updateRoomReview(Room room) {

}
{% endhighlight %}

위처럼 SpEL형식으로 된 구체적인 key를 주지 않는다면 스프링 캐시는 메소드와 파라미터를 기준으로 Serialize를 해서 레디스 키로 넘겨버린다. 바이트배열로 키가 생성되다보니 이 부분이 좀 찾기 힘들었음. (스프링 Serialization - TODO)

막 레디스 입문이라 배워야할 게 너무 많다. ^^;


<font color='#909194'>Last updated: March 29, 2024</font>