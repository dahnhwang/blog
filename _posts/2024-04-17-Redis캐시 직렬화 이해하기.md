---
title: "Redis캐시 직렬화 이해하기"
layout: post
---

지난 포스팅의 레디스 관련 디버깅을 하며, 레디스 키가 잘 들어갔는지 이빅트 처리는 잘 되었는지 확인하는데 꽤 애를 먹었는데 이유는 캐시키가 사람이 읽을 수 없는 바이트배열로 변환이 되어 완전히 동일한 키인지 확인하기 어려웠기 때문이다. 

## JdkSerializationRedisSerializer

왜 이상한 바이트배열들이 레디스 키로 들어가있나했더니, 레디스 자바 클라이언트인 Redisson의 설정파일에서 redisTemplate의 세팅값으로 자바의 기본 Serializer를 사용하도록 되어있기 때문이었다.

{% highlight java %}
redisTemplate.setDefaultSerializer(new JdkSerializationRedisSerializer());
{% endhighlight %}

`JdkSerializationRedisSerializer`는 DefaultSerializer를 통해 객체를 output stream으로 직렬화시켜 바이트배열로 최종 아웃풋이 만들게 된다. ([JdkSerializationRedisSerializer 공식문서](https://docs.spring.io/spring-data/redis/docs/current/api/org/springframework/data/redis/serializer/JdkSerializationRedisSerializer.html)) 따라서 [2024-03-28-Redis캐시 @CacheEvict 사용하기](https://dahnhwang.github.io/Redis%EC%BA%90%EC%8B%9C-@CacheEvict-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/)에서 말미에 언급했던 것처럼 오브젝트의 null값과 빈값('')이 다르게 인식하도록 처리된다.

## 직렬화 실제 코드테스트 

[JAVA 직렬화(Serialization)과 역직렬화(Deserialization)] (https://inkyu-yoon.github.io/docs/Language/Java/Serialization#%EC%A7%81%EB%A0%AC%ED%99%94%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0)

위 블로그가 잘 정리되어있어서 코드테스트 부분을 참조하였다. 바이트 배열로 생성된 직렬화 데이터를 base64로 변환하여 콘솔창에서 문자깨짐현상없이 동일한 오브젝트에 대해 동일한 직렬화 데이터가 생성됨을 확인할 수 있었다. 

## 내가 앞으로 레디스캐싱 개발을 맡는다면 

바이트배열로 레디스키를 생성할 경우 디버깅이 어렵기 때문에 StringRedisSerializer을 사용하는 것이 바람직한 것 같다. [스프링 공식문서](https://docs.spring.io/spring-data/data-redis/docs/3.0.11/reference/html/#redis:string)에서도 언급이 되고 있는 부분이다. 

<font color='#909194'>Last updated: April 18, 2024</font>