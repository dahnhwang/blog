---
title: "검색 알고리즘"
layout: post
---

검색방법에 따라 비교 검색방식(Comparison Search Method)와 계산 검색방식(Non-comparison Method)으로 나눠지는 검색 알고리즘을 정리해본다.


### 비교 검색방식(Comparison Search Method)

교실에 학생 5명의 사물함이 있다. 모든 사물함을 1번부터 5번째 것까지 차례로 열면서 그 안에 'c'라는 글자가 있는 사물함 번호를 찾는다. 이게 바로 <font color="crimson">순차검색(Sequential Search)</font>이다. 답이 나올때까지 순차적으로 모든 사물함을 열어서 같은지 다른지 비교해야 하므로 시간복잡도는 O(n)이다.

{% highlight python %}
cabinet = ['f','b','c','e','a']
search = 'c'

def sequential_search(cabinet, search):
  answer = -1
  for i, object in enumerate(cabinet):
    if object == search:
        answer = i
  return answer
  
print(sequential_search(cabinet, search))
{% endhighlight %}

Output:
```2```

그런데 만약 사물함 안의 글자들이 알파벳 순으로 정렬이 되어있다면 검색을 더 수월하게 할 수 있다 (<font color="crimson">정렬된 순차검색(Sorted Sequential Search)</font>). d보다 더 뒷순서인 e를 만나기 전까지 d가 발견되지 않는다면 모든 사물함을 열어볼 필요없이 -1(찾는 대상이 없음)을 리턴하면 된다.

{% highlight python %}
sorted_cabinet = ['a','b','c','e','f']
search = 'd'

def sorted_sequential_search(cabinet, search):
  answer = -1
  for i, object in enumerate(cabinet):
    if search >= object:
        if object == search:
            answer = i
  return answer
  
print(sorted_sequential_search(sorted_cabinet, search))
{% endhighlight %}

Output:
```-1```

순차검색과 동일한 비교방식이지만 첫번째 위치부터가 아니라 중간 위치부터 탐색을 시작하는 <font color="crimson">이진 검색(Binary Search)</font>은 가운데 값을 기준으로 왼쪽과 오른쪽 두 부분으로 나누어서 검색하므로 보간 검색(Interpolation Search)라고도 부른다. 검색 범위를 반으로 나누고 검색을 수행하는 이 같은 방법을 `분할 정복(Divide and Conquer)`이라고 한다. 이진 검색의 경우 시간복잡도가 O(log<sub>2</sub>n)로 순차검색에 비해 성능이 높지만 아래와 같은 제약사항이 있다.

1. 자료가 정렬되어 있는 상태에서만 사용 가능
2. 자료의 삽입이나 삭제 등 변경이 있는 경우 재정렬 필요

{% highlight python %}
cabinet = ['f','b','c','e','a']
sorted = sorted(cabinet)

def binary_search()

{% endhighlight %}


### 계산 검색방식(Non-comparison Method)



<font color='#909194'>Last updated: June 23, 2021</font>