---
title: "검색 알고리즘"
layout: post
---

검색방법에 따라 비교 검색방식(Comparison Search Method)와 계산 검색방식(Non-comparison Method)으로 나눠지는 검색 알고리즘을 정리해본다.

<br>

### 비교 검색방식(Comparison Search Method)

교실에 학생 5명의 사물함이 있다. 모든 사물함을 1번부터 5번째 것까지 차례로 열면서 그 안에 'c'라는 글자가 있는 사물함 번호를 찾는다. 이게 바로 <font color="crimson">순차검색(Sequential Search)</font>이다. 답이 나올때까지 순차적으로 모든 사물함을 열어서 같은지 다른지 비교해야 하므로 시간복잡도는 O(n)이다.

{% highlight python %}
cabinet = ['f','b','c','e','a']
search = 'c'

def sequential_search(cabinet, search):
  answer = -1
  for i, object in enumerate(cabinet):
    if object == search:
        answer = i
  return answer
  
print(sequential_search(cabinet, search))
{% endhighlight %}

Output:
```2```

그런데 만약 사물함 안의 글자들이 알파벳 순으로 정렬이 되어있다면 검색을 더 수월하게 할 수 있다 (<font color="crimson">정렬된 순차검색(Sorted Sequential Search)</font>). d보다 더 뒷순서인 e를 만나기 전까지 d가 발견되지 않는다면 모든 사물함을 열어볼 필요없이 -1(찾는 대상이 없음)을 리턴하면 된다.

{% highlight python %}
sorted_cabinet = ['a','b','c','e','f']
search = 'd'

def sorted_sequential_search(cabinet, search):
  answer = -1
  for i, object in enumerate(cabinet):
    if search >= object:
        if object == search:
            answer = i
  return answer
  
print(sorted_sequential_search(sorted_cabinet, search))
{% endhighlight %}

Output:
```-1```

순차검색과 동일한 비교방식이지만 첫번째 위치부터가 아니라 중간 위치부터 탐색을 시작하는 <font color="crimson">이진 검색(Binary Search)</font>은 가운데 값을 기준으로 왼쪽과 오른쪽 두 부분으로 나누어서 검색하므로 보간 검색(Interpolation Search)라고도 부른다. 검색 범위를 반으로 나누고 검색을 수행하는 이 같은 방법을 `분할 정복(Divide and Conquer)`이라고 한다. 이진 검색의 경우 시간복잡도가 O(log<sub>2</sub>n)로 순차검색에 비해 성능이 높지만 아래와 같은 제약사항이 있다.

1. 자료가 정렬되어 있는 상태에서만 사용 가능
2. 자료의 삽입이나 삭제 등 변경이 있는 경우 재정렬 필요

{% highlight python %}
cabinet = ['f','b','c','e','a']
sorted = sorted(cabinet)
search = 'a'

def binary_search(sorted, low, high, search):
    mid = (low + high) // 2 
    if search == sorted[mid]:
        return mid
    elif search < sorted[mid]:
        return binary_search(sorted, low, mid-1, search)
    elif search > sorted[mid]:
        return binary_search(sorted, mid+1, high, search)
    
result = binary_search(sorted, 0, len(sorted)-1, search)
print(result)
{% endhighlight %}

Output:
```0```

앞서까지는 데이터 형태가 list로 주어지는 경우 사용할 수 있는 검색방법이었고, 데이터 형태가 트리 구조로 주어지는 경우에는 역시 O(log<sub>2</sub>n)의 시간복잡도를 가지는 이진 트리 검색(Binary Tree Search)를 사용하여 검색할 수 있다. 이는 추후 별도의 포스팅으로 정리해보겠다.

<br>

### 계산 검색방식(Non-comparison Method)

앞선 비교 검색방식과 다르게 계산을 통해 검색하는 방식의 대표적인 것은 <font color="crimson">해싱</font>이다. 5명의 학생에게 5개의 사물함을 배정하는데 자기 이름을 넣으면 0에서 4 사이의 사물함 번호를 알려주는 간단한 프로그램 `simple_hashing`을 사용했다고 하자. 이렇게 사물함을 배정한 후 그 결과를 `paper`에 적어두었다. 

{% highlight python %}
names = ['a','c','e','b','d']
paper = {}

def simple_hashing(name):
    return ord(name) - 97
    
for name in names:
    cabinet_index = simple_hashing(name)
    paper[name] = cabinet_index

print(paper)
{% endhighlight %}

Output:
```{'a': 0, 'c': 2, 'e': 4, 'b': 1, 'd': 3}```

'a'라는 이름의 학생은 0번 사물함, 'b' 이름의 학생은 1번 사물함, 마지막 'e' 이름의 학생은 4번 사물함에 배정되었음을 알 수 있다. 이 `paper`라는 딕셔너리 구조가 해시 테이블로 사용되었음을 알 수 있다. 이 해시 테이블이 있다면 특정 학생의 사물함이 어디인지 굉장히 빠르게 검색해낼 수 있다. 시간복잡도가 O(1)이다.

{% highlight python %}
search = 'a'

print(paper.get(search))
{% endhighlight %}

Output: ```0```

<font color='#909194'>Last updated: June 24, 2021</font>